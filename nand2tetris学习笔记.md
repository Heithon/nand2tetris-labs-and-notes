---
title: nand2tetris学习笔记
date: 2022-12-20 20:47:51
tags: 
- 计算体系结构
- 操作系统
- 编译原理
- 硬核手搓
category:
- CS基础知识
---

![image-20221220181728418](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212201817519.png)

徒手搓电脑，并在上面跑俄罗斯方块

更新至第一章：布尔逻辑

<!-- more -->

## Week0:课程简介和一些背景知识

### 一. nand2tetris课程介绍

​	    nand2tetris即from nand to tetris(to和2的英文读音一致)，翻译过来就是从与非门到俄罗斯方块。这是一门由希伯来大学的两名教授开发的计算机基础知识课程。课程以项目驱动，从最基础的逻辑门开始，一步步构造一个完整的名为Hack的计算机系统，包括基础的硬件结构，还有软件层面的操作系统。我们甚至要构建一个名为jack的编程语言，用它来写操作系统，最后也是用它写一个俄罗斯方块小游戏在我们制造的这个计算机上运行。

​		通过这门课程，我们可以俯瞰整个计算机，拉通理解整个过程：从里面的每一个零件的协同运作，一直到能在屏幕上运行我们的应用程序。其中包含数字电路，计算机组成原理，操作系统，编译原理等等知识，但是都没有特别深入。这门课最大的价值是为我们展开了一幅计算机知识的地图，我们可以在学完整个课程后，选择自己喜欢的地方深入。另外课程提供的实验是这个课程的最大亮点，可以说这个实验就是课程本身，它提供了一种动手制造整个计算机的途经，让我们在实践中学习知识，尤为可贵。<b style="color:red">因此学习这门课程尽量要动手实践</b>

​		本课程分为大的两部分，第一部分是硬件，第二部分是软件，自底向上的构建计算机系统。



### 二. 计算机的诞生

<p style="padding:0px 10px;background-color: lightgreen;border-left:4px #555 solid">  tips: 本小节为本人凭借兴趣了解的题外话，可以跳过 </p>



​		学习的过程中也在了解一些课余的知识，比如**计算机是怎么诞生的？** **计算机为什么可以是计算机？**

​		计算机发明的最主要目的便如名字所说：计算。为了计算我们向前甚至可以追溯到结绳记数，但这些“古典”的计算方式都和我们现在的通用计算机相去甚远。关于现代计算机的开端，我们可以放眼到1936年由图灵提出的**图灵机**模型。图灵机是一个抽象的概念，它抽象了人们使用纸笔运算的过程，为自动化的计算提供了可能。

​		想想我们用纸笔是怎么运算的？首先，我们肯定有解题的思路，或者说叫算法，其次我们的问题有一些初始的值。我们的计算过程就是通过我们的解题思路，不停的对这些值进行修改，直到改成目标答案。而图灵设想了一个自动化的机器来完成上述操作，具体如下：

![什么是图灵机](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212201905375.jpeg)

​		如上图，这是一个经典的图灵机模型图。其中包含这几个部分：

  - 一条无限长的纸带，纸带被划分成一个个小格子，每个格子只有三种状态 （空和1）

  - 纸带上方的方盒子是一个读写头，可以在纸带上面按照格子移动，它可以做三种操作：

    1. 读取格子数据
    2. 编辑格子里的数据
    3. 向左或向右移动

  - 横插在方盒子上的是图灵机当前的状态，图灵机可以有许多不同的状态。

  - 方盒子上面的纸张是一些指令（也就是前文纸笔运算时的解题思路）。每条指令分为状态，和操作，控制读写头在指定状态执行指定操作。（状态可以由纸带上的数据和图灵机本身的状态共同决定）

	
	

​		图灵机初始的时候，会有一个状态，纸带上也有一些初始值。然后读写头根据当前状态对应的指令，做出编辑数据，移动，改变状态等操作。到了下一个状态，又执行对应的操作。这样一个状态一个状态的迭代，不停的修改纸带上的数据，到最终得到结果时，就让图灵机进入停机状态。

​		上面的过程描述很抽象，这里推荐个视频可以帮助理解：<b style="color: blue;">[图灵机运作原理及示例](https://www.bilibili.com/video/BV13v4y1w7yM/?share_source=copy_web&vd_source=c0b7e2971676981be548dbddf193bcc9)</b>

​		无论是否理解这个机器，至少我们知道，它能通过一些指令，用读写头在纸带上修修改改，而且过程是一步一步的，一条指令一串操作这样修改，最后得出结果。这为现代计算机的实现提供了方向，而且科学家们也证明了这个模型的可行性（具体可以学习计算理论和数理逻辑相关知识）。

​		我们要造一个计算机，首先得要有个东西装指令吧，还得有个东西能理解指令吧，还要能判断当前的状态；我们还要有个无限长的纸带，虽然不太现实，但至少得足够长吧；还要有个能在纸带上游走，对纸带数据进行增删改查的读写头吧；还有那个标记当前状态的玩意也得有吧。通过后面的学习，我们可以知道，现在目光所及的通用计算机几乎都是按照这个框架制造的。

下一章我们要学习**布尔逻辑**，这也是个划时代的玩意，它将概念上的形式逻辑落地成了硅片上的电路，用看得见摸得着的东西来呈现只有思维里和纸上符号才能表示的逻辑。计算时我们脑子里的解题思路，就有了一个被实体化的可能，图灵机的指令那块也有了实现的希望。事实上在布尔逻辑和电路的帮助下，我们能把各种信息数字化到芯片里，进行存储，读取和处理等等操作。正是这些伟大的思想和技术的综合作用，才带了如今非凡繁盛的互联网时代。

### 三. 学习环境和资料

学习这一套课程只需要有一台普通的电脑就行，win和linux系统都可。然后需要下载的资料链接放下面：

1. 课程视频教程b站：<b>[【高清-中字-公开课】依据基本原理构建现代计算机：从与非门到俄罗斯方块(点击观看)](https://www.bilibili.com/video/BV1KJ411s7QJ/?share_source=copy_web&vd_source=c0b7e2971676981be548dbddf193bcc9)</b> 

2. 课程官网：<b>[Nand2Tetris（点击进入）](https://www.nand2tetris.org/)</b>
3. 课程配套软件和练习文件：<b>[网盘下载（提取码：2222）](https://pan.baidu.com/s/1oX45mzHeQREl9IGp6YQe6g?pwd=2222)</b>
4. 课程配套书籍《计算机系统要素：从零开始构建现代计算机》：<b>[网盘下载（提取码：2222）](https://pan.baidu.com/s/1yxG3ENOcnZrpe7BNoTsBfA?pwd=2222)</b>

	本人的环境是Windows系统，我自己学习的方式是以看书为主，然后有不懂的地方再去看视频，学完一章就直接动手实验。





## Week1:布尔逻辑

### 一. 布尔代数

布尔逻辑是一套由**乔治布尔**于十九世纪中叶定义的逻辑系统。所谓逻辑，就是对正确推论的研究，如何根据一系列**前提**，推论出一个**正确的结果**。下面我们来看看布尔逻辑的内容。

首先我们知道一个命题，它不是真的，就是假的。假设有命题a为真，命题b也为真，那么有个命题c内容是a且b，它是真的还是假的？我们可以感性的举个例子，如果“这个棒棒糖是甜的”是真命题，“这个棒棒糖是球形”也是真命题，那么“这个棒棒糖是甜的并且它是球形”也显然是真命题。我们可以发现，前提a，b是真的，那么 a且b也是真的。我们把这种形式抽离出来，只要满足这个形式，不管内容是啥（不管ab是啥），它都成立。

这里的 “且” 是语言上表达的一种逻辑连接词，也可以叫 “与” 表示两者都满足；类似的还有 “或” ，a或b，其中至少一个为真就为真；还有 “非” ，这个字只作用于一个命题，而前两者连接两个命题，如果a是真的，那么非a就是假的，反之亦然。与，或，非组成了基础的三种逻辑连接词。所以可以抽象出来：

- a且b：必须a和b都是真的这个命题才真
- a或b：a和b中至少一个是真的，这个命题就是真的
- 非a：如果a是真的，那么这个命题是假的，a是假的这个命题就是真的

布尔把 "真" 设为1，把 “假” 设为0。然后用上述连接词，1或0为1, 0或0为0, 1或1为1，等一下，这不和加法一样了吗只是1+1比较特殊，还是得1。同样，对于 “与” 来说，就和乘法一样。而 “非”，无非是把1变为0,0变成1。**这些真真假假是可以像数字一样进行计算的！**只是这里的数字只有0和1（这很容易联想到二进制），而且没有进位，1+1还是1，我们称这种计算叫逻辑运算。由此，**布尔代数**诞生了。

> 一些逻辑运算规则：
>
> 或：1+1=1；1+0=1；0+0=0；有1为1
>
> 且：1x1=1；1x0=0；0x0=0；有0则0
>
> 非：1'=0；0'=1；唱反调

在布尔代数中，我们称这些连接词为布尔算子，就和普通代数中的加减乘除一样。**与或非**就是最基础的布尔算子。除了最基础的三个，我们还可以了解**与非**，就是先与再非；**或非**，先或再非；**异或**，连接两个命题，同真同假的话结果是假，只有真假不同结果才是真；**同或**，与异或相反，只有同真同假时结果才为真。普通的四则运算有一些交换律结合律之类的规律，还有些化简公式，布尔代数也不例外，如下图（不用刻意记住，需要时查找即可）。

![image-20221221122348025](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211223212.png)

![image-20221220235158994](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212202352608.png)

![image-20221220235248586](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212202352620.png)

#### 布尔函数

在普通的代数中，我们不仅有1+1这种具体的式子，也有x+y+2这种带着未知量(变量)的式子，当x和y取不同的值时，就会得到不同的结果，这个式子只是表示一个计算的过程，我们可以称其为函数。布尔代数同样也有布尔函数，或者叫布尔表达式，只是其中的运算变成了逻辑运算，其中的变量只能取0或1。函数体现了一种**黑箱思想**，我们的表达式的变量需要接收一些值，然后经过表达式的处理，得到一个结果。比如布尔表达式 (x+y)z'，需要接收三个具体的值分别给xyz三个变量，我们把表达式本身想象成一个黑盒子，用符号f(x,y,z)表示，f是盒子的名字，盒子上有三个入口分别叫x,y,z，还有个出口出来运算结果。假设黑盒子内部可以自动化的处理。当我们把1,1,0这三个值扔进x,y,z这三个入口，那么盒子就可以产生出结果1，因为内部运算(1+1)x0'的结果为1，可以写为f(1,1,0)=1。xyz三个变量，每个变量只能取0或者1两个值，所以一共有2的3次方也就是8中取法，我们把所有的输入情况和对应结果找出来，并列成一张表，就成了**真值表**。

![image-20221221123555773](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211235807.png)

#### 真值表反推函数表达式：

上面我们说了，函数就是一个黑盒子，给它输入，就一定会给一个固定的输出。反过来说，如果我们一开始不知道盒子里是啥呢？我们只知道有几个输入，还有对应输入应该是什么结果，换句话说就是只知道真值表！我们是否可以反推出盒子里的表达式呢？这也符合现实的很多情况，我们知道这个问题有哪些条件，我们也知道自己要什么结果，但是我们需要一个把条件变为结果的手段。这其实是可行的，我们先只关注输出为1的那些行，对于每一行，我们用与来连接xyz。然后我们关注这一行xyz分别的取值，比如第三行xyz分别取010，那么取0的那个字母就要进行非运算，第三行就写成x'yz'。然后把输出为1的三行都这么处理，就能得到三个与连接的式子：x'yz'，xy'z'和xyz'，接着把这三个式子用或连接，就成了x'yz'+xy'z'+xyz'，这其实就是这个真值表的函数表达式了，最后用上面的计算规律化简就成了我们熟悉的(x+y)z'。我们可以得到化简过程中你可能会发现中途有好多种表达式，所以一个真值表可能对应不止一个黑盒子，我们通常选取最简单的那一个。另外你还可以发现，**不管多复杂的真值表，只用与或非三种算子就能表示**。

![image-20221223111143868](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212231111931.png)

#### **与非的妙用**：

与非(nand)，(xy)'，是一个十分牛的算法，因为只用与非代替基础的三种算子：与或非。这用上面运算规律中的**德摩根律**很容易能求出。进而我们可以把任何表达式，都转化为只用与非这一种算子的表达式。这在之后构建硬件中起了非常大的作用，你也可以发现课程题目中的nand说的就是与非门，这是这门课程项目的最基础的元素。

![image-20221221131327050](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211313126.png)

#### **与现实世界连接**：

有了上面知识，我们就可以自己设计一个函数了，给这个函数喂一些0和1，就能吐出想要的0和1。但是这有什么用呢？上一章第二节我们谈到了图灵，他有个好朋友叫**香农**，香农在1938年的硕士论文《继电器与*开关电路*的符号分析》中将这些概念上的逻辑与物理世界连接，让这些理论的落地有了可能。香农是研究通讯的，他发现电从一点到另一点本身不是信息，而电的有无却可以是信息。比如我们了解的电报，通过电路开关以及开关的时间，就可以表示语言信息。而电路的开关引起了香农的注意，这电路一开一关两种状态，不是正好对应了布尔逻辑中的1和0两种状态吗？我们将信息转化为0和1，然后用电路的开关去表示，我们还能用真值表设计“黑盒子”去处理这些信息，也就是说，我们能把逻辑放到看得见摸得着的电路板上了。

我们再回想一下上一章的图灵机，其中一个要考虑的点就是如何把我们的计算思路给存到机器里去，如何让机器去理解。现在看来，这一切都有了实现的可能。下一节**逻辑门**，我们将把理论落实，把抽象的与或非转化为具有物理实体的与门，非门，或门，还能会制造后面需要用到的一些门电路或者说芯片。你还会发现我们的门电路或者说芯片，就是给一堆输入的0和1，然后输出特定的0和1，设计门电路就是在设计布尔函数。

<p style="color:#888;background-color:lightyellow;padding:0px 10px;
border-left:4px #999 solid;">拓展：香农也是一位很有趣的科学家，这里有一部纪录片可以了解下：<a href="https://www.bilibili.com/bangumi/play/ss34520/?from=search&seid=4357879265608450011&spm_id_from=333.337.0.0">《香农传》</a></p>



### 二. 门电路

#### 从编码说起：

我们知道电脑里面就是一堆电路，稍微了解计算机的可能听说过，电脑只会二进制语言，只能读懂0和1。但是我们玩电脑，可以看图片，听音乐，可以看视频，甚至在大型游戏中模拟了另外一个现实，你可以在一个空间中畅游互动。显然计算机表现出来的不只是0和1，这都离不开编码的帮助。

像上一节说的电报，我们可以通过一些规则，把不是0和1的信息变成0和1。比如我们规定字母a是000，b是010，c是100，这样字母信息就变成了0和1的信息可以传入电脑中。向电脑输入字母应该是按键盘，安一个按钮可以输出一些0和1的信号，我们把这些信号变成abc字母规定的编号。比如按了a键，键盘输出101101，然后我们把它转化为000，这个过程就是**编码**。电脑怎么展示这些字母呢，首先它得有个屏幕，屏幕也是由0和1控制的，通过屏幕上有的地方通电发光，有的地方不通电变暗就能显示图案。很显然屏幕上面这么多发光点，控制屏幕的0和1是和字母不同的。也就是说我们需要一个翻译，来把字母的编码转化为屏幕可以显示的0和1，然后控制屏幕怎么发光，这个过程就是**译码**。

上述过程我们可以猜想有两个东西，一个编码的东西，一个译码的东西，它们输入一些0和1，吐出一些0和1，这不就是上一节的布尔函数吗？通过编码译码，我们就可以把现实的信息数字化。当然上述例子极其粗糙，整个计算机系统是一个超级工程，肯定不会如此简单，后续我们也会学习更细节的东西。

#### 在电路中实现逻辑

<p style="background-color: lightgreen;padding:0px 10px;
border-left:4px #555 solid;">  tips: 这一小点为拓展，稍微了解即可 </p>

所谓的逻辑门就是逻辑电路中最基本的组件，可以实现与或非这些操作的电路。

课程并没有要求我们去了解最基础的与非门电路是怎么实现的，我们前面说了，有了与非门，就可以实现所有的布尔函数。课程默认与非门是造好了的，我们拿来用便可，但我还是稍微了解了一下具体的实现。

一切要从发明大王爱迪生说起，爱迪生在捣鼓灯泡的过程中发现了爱迪生效应，而弗莱明通过爱迪生效应制造了二极管，一种可以单向通电的元器件。后来福雷斯特在二极管的基础上制造了三极管，三极管在二极管的基础上增加了第三个端，在第三端施加少量电压便可以使另外两端导通。

![image-20221221170306412](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211703536.png)

![image-20221221170322087](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211703168.png)

我们可以用符号来表示三极管，并用三极管来构建基本的逻辑门。

![image-20221221171127619](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211711668.png)

![img](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211711063.png)

我们可以看到，这时候的三极管还是类似灯泡一样，烧的灯丝，我们称其为**电子管**。电子管体积巨大，功效奇高，而且寿命不长，所以用电子管构建的第一台计算机，也是体积庞大的功耗怪兽。后来利用半导体材料制造的**晶体管**横空出世，晶体管利用硅的特性来制造，体积小巧，功耗低，很快全面代替了电子管。后来人们发现，制造晶体管电路的材料可以被硅包办，为什么不直接把电路刻在一块硅片上呢？于是集成电路出现了，所有的元器件都是直接刻在硅片上，并且体积越来越小以至于到了纳米级别，数量越来越多到达千亿级别，让计算机真正成为了能握在掌心的超级工程。

晶体管的工艺也一直在更新，为了更加稳定更加高效。现在比较流行的是**cmos**制程，用mos管来代替三极管，实现更稳定的性能。

无论如何，我们的课程假设我们已经有了许多的**与非门**(nand)，你可以把它想象成一个小黑盒，盒子上有三根暴露的电线abc，电线只有两种状态，可以是有电和没电，也可以是高电压和低电压。c电线的状态总是(ab)'。我们将只用这些与非门来构造整个计算机。

#### 用与非门构建基础的门电路

还记得学布尔函数时的黑盒思想吧，我们先来把这些基本的门变成带接口的盒子画出来：

![image-20221221173348672](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211742060.png)

![image-20221222221828856](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212222219330.png)

这些其实就是逻辑门的电路符号。我们要实现一个门电路，其实就是求它的布尔表达式，有了这个表达式我们就可以根据表达式连接电路。下面以非门为例展示如何构建：

- 首先我们确定或门的输入和输出，它有一个输入a,有一个输出out。

- 我们知道c=a+b,但是我们要化为全是与非门的形式，所以out=(aa)'，也就是a和a本身与非一下
- 接下来就是按照式子画图：
  - ![image-20221221174829356](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211748512.png)

有了非门，我们就可以把非门用在后面的逻辑门制造中，而不用考虑非门如何制造，同理我们可以画出其他几个基础逻辑门的电路图。

![image-20221221175156811](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211751914.png)

除了与或非异或，我们还需要两个特殊的逻辑门——**multiplexor**和**demultiplexor**，简称**mux**和**dmux**。

mux的有三个接收端和一个输出端，三个接收端分别为a,b,sel，输出端为out，sel可以选择让out输出的是a的值还是b的值。比如a为0，b为1，当sel为0时，out就输出a的值0，当sel为1时就输出b的值为1。

dmux可以看做是mux的逆过程，dmux有两个接收端，in和sel，两个输出端a，b。sel可以选择让in从a出来还是b出来，另一端一直为0。比如说in输入一个1，sel=0时，a就输出1b就输出0，sel=1时，a就输出0b就输出1。

![image-20221221180334312](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211803368.png)

以上两个电路比较复杂，不能像基本门电路一样直接写出表达式，所以我们采用真值表法来求出表达式

![image-20221221180450827](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212211804000.png)

<p style="padding:0px 10px;background-color: lightgreen;border-left:4px #555 solid">  tips: 一定要自己动手推导下，从表达式的推算到电路图的绘制，这将极大的帮助理解 </p>

#### 多位基本门和多通道逻辑门

在很多时候，我们需要同时把许多信号做相同的操作，或者说把一组信号当作一个整个信号进行处理。这时我们就需要**多位逻辑门**了，根据后面课程的需要，我们将要制作16位的与或非门和mux，分别叫做and16，or16，not16，mux16。以前输入的一个信号a变成了一组信号，我们可以用数组来表示：a[16]。举个例子：a[16]是1111111111111111一共十六个1，我们的not16可以直接把这组信号变为0000000000000000十六个0。要制作这样的多位门其实很简单，**直接把16个一位的基础逻辑门拼起来装进一个大黑盒子**就行了。

而**多通道逻辑门**主要说的是mux和dmux，通过前面学习可以知道，mux和dmux都可以用sel这个输入来控制a和b两个端。那么sel能否控制更多呢，比如控制4个或者8个端？要创造这样的门是有一定技巧的，我们先从4个端的mux看起，要用sel端来控制4个16位的信号，a[16]，b[16]，c[16]，d[16]。首先想到的是以前sel只有一位，不是0就是1，这样只能控制两个信号。现在有了4个信号，我们可以把4个信号俩俩分组，sel为0就选择a[16]和b[16]，sel为1就选择c[16]和d[16]。可是sel只有一位啊，只能选择其中的两个，我们顺其自然就能想到再给sel来一位，就能从前一位选中的两个中选择一个，就实现了4选1啦。一个mux16可以从2个中选一个，所以要从4个中选2个就需要2个mux16，他们的sel接同一个信号构成1位。从选中的两个中再选一个，又需要一个mux，它的sel又是1位。所以要制造一个mux4way16，需要3个mux16。sel就升级为了两位的sel[2]，00，01，10，11正好分别对应四个通道。

上面这段描述比较抽象，不理解可以结合下面的图来看，mux8way16可以同理由mux4way16来构建。而dmux4way和dmux8way需要一点逆向思维，可以自行思考下：

![image-20221222231151426](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212222311587.png)

还是老话，尽量自己动手画一画，印象深刻。

下一节我们将要学习用一种类似编程语言的东西来描述这些零件。我们将用代码描述这些零件，这样我们就可以在电脑上对这些零件进行模拟测试了（毕竟要用真家伙做这些电路也挺费事）。

### 三. 硬件描述语言HDL

由于用实物做实验条件太难，而且不可控的因素很多，所以本课程采用软件模拟的方式进行，也就是说我们造的这台电脑是在我们自己的真电脑上运行的。所有的逻辑门都通过硬件描述语言HDL来创建。

#### 什么是HDL

通过上面的学习我们知道，一个逻辑门可以看成一个黑盒，黑盒外面有输入和输出接口，黑盒的里面有各种逻辑门电路。HDL就是一种计算机语言，它可以用来描述这样一个逻辑门或者芯片。本课程使用的HDL是老师为课程设计的简化版本，和设计生产使用的HDL语言差距还是不小，但是也突出了其精髓。下面是用HDL语言描述的一个与门：

```
//双斜线可以写注释
    
CHIP and{	//CHIP 芯片名字{} 大括号内用于描述内容
    //大括号内分两部分，第一部分规定黑盒子外的输入输出端口
	IN a,b;		//IN部分规定了输入端口
	OUT out;	//OUT部分规定了输出端口
	
	//第二部分规定了黑盒子里面的线路怎么连接的
	PARTS:
	Nand(a=a,b=b,out=nandab);	//我们以电路里的每个逻辑门为线索，规定每个逻辑门的输入和输出
	Not(in=nandab,out=out);
}
```

将这样一串代码写进一个文件中，文件的名字必须和芯片的名字一样，然后后缀为.hdl，比如上面这个芯片的名字就叫and.hdl。接着就可以放进专门的软件里调试了。

第0章我们分享了课程需要的所有软件资源，打开课程配套软件 `nand2tetris\tools\HardwareSimulator.bat`(Linux打开.sh文件)，将上面的and.hdl导入进软件中，就可以对这个与门进行调试。

![image-20221223113817779](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212231138837.png)

可以在设置输入那里输入想要的值，然后点一下计算输出的按钮，就能在展示输出里看到对应的输出。

我们可以手动输入每一种情况，看看输出正确与否，就能验证我们的设计是否正确。但是有的芯片输入的组合极多，手动输入效率实在太慢了，因此这个软件还可以导入另外两种后缀的文件 .tst脚本文件和 .cmp比较文件。.tst文件可以通过导入脚本按钮导入，课程资料里提供了每个芯片需要的测试脚本，经过测试脚本测试后的芯片，会输出一个.out文件，这个文件其实就是这个芯片的真值表。.cmp文件是课程提供的正确芯片应该输出的真值表，我们可以比较自己输出的.out 文件和.cmp文件是否一致。后面再来详细说说导入脚本的一些问题。

#### HDL基本语法

通过上面的例子我们可以了解到，一个.hdl文件就是一个芯片，而代码内容必须包含在如下的大括号里，这个结构规定了**芯片的名字**，而且**必须和文件名字**一致。内部分为两部分，一部分定义输入和输出，即黑盒外的接口；一部分定义内部的零件和电路，写在PARTS：后面。

```
CHIP 芯片名字{
	//定义输入输出
	IN
	OUT
	//定义内部线路
	PARTS:
}
```

定义输入输出采用如下格式，IN 后面跟输入接口的名字，OUT后面跟输出端口的名字，这个名字可以自定义，一般多个输入或者多个输出，我们定义为a,b,c...，如果只有一个输入那么就叫in，只有一个输出就叫out。像mux和dmux这种有个选择的输入，我们就叫它sel。一次定义多个接口，名字中间用逗号隔开，每一行分号结尾

如果有很多位的话，可以用数组的表示法，比如a[16]，sel[2]，表示16位和2位的信号。

```
CHIP 芯片名字{
	//定义输入输出
	IN a[16],b,in,sel;
	OUT a,b[16],out;
	//定义内部线路
	PARTS:
}
```

定义内部线路是重头戏，通过前两节的学习，我们知道内部线路也是许多逻辑门组成的。信号的流动过程大概是  输入口->逻辑门输入->逻辑门输出->逻辑门输入->逻辑门输出->......->逻辑门输出->输出口。因此我们只用关注内部的逻辑门是怎么相互连接的。下面用mux举例，先再回顾下mux的电路图：

![image-20221223120007160](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212231200216.png)

黑盒子里有四个逻辑门，一个非门，两个与门，一个或门。对于非门，它的输入是sel，输出是给与门，我们就可以这样描述它`not(in=sel,out=outa)`;，not是非门的名字，也就是非门这个.hdl文件的名字，in=sel表示输入的是sel。out=outa，我们要把非门的输出连接到与门，可以这样操作，先给输出的那条电线取个名字叫outa，待会把那个与门的输入接到电线outa上就行了，我们称这样的中介一样的线叫做**管线**，多位的就叫**总线**。

四个零件都这样描述一下，就是下面的代码：

```
CHIP mux{
	IN a,b,sel;
	OUT out;
	
	PARTS:
	Not(in=sel, out=notsel);
	and(a=a,b=notsel,out=outa);
	and(a=b,b=sel,out=outb);
	or(a=outa,b=outb,out=out);
}
```

值得注意的是：软件中只有与非门(nand)是可以直接使用的，需要先自己用nand门构建与或非门，上述文件mux.hdl在运行时会去寻找同一目录下的Not.hdl，and.hdl，or.hdl，而这些都是自己构建的，输入输出口都得和自己定义的吻合。

还有一个问题是**多位数据的传输**，比如a[16]这个信号，你可以想象一根电线里有16根小电线，给它们编个号，注意得从0开始，就是0,1,2,3,4...14,15。当需要把前8个信号接到outa这个总线上时，我们可以这么写 a[0..7]=outa，outa不用去规定有几位，它由输入的信号自动决定，后面保持不变。如果需要把多位信号中的一位输出到管线b上，可以这样写 a[2]=b，就是把a的2号电线(第三个信号)输出到b上。这里的a[2]是在PARTS里的，表示信号的编号，而a[2]在IN或OUT后面，则表示a有两位信号，和其他编程语言里数组的定义和取值差不多。

软件的脚本使用，个人认为还是视频更加直观，这里贴下链接：<b><a href="https://www.bilibili.com/video/BV1KJ411s7QJ?p=10&vd_source=2185c480eb8959660534c8145bce45ff">硬件调试软件的使用</a></b>

下面补充一些脚本的注意事项，以mux的测试脚本为例，你可以通过修改脚本来做一些自定义的操作：

![image-20221223121615508](https://mypic-1309350050.cos.ap-chongqing.myqcloud.com/img/202212231216551.png)

#### 开工

现在我们的目标是把上一节计算并画图出来的门电路全部转化为hdl文件，并且都要通过软件的测试。书上为我们规定了文件名称，和输入输出接口的名称，需要动手的是PARTS：后面的部分，打开文件夹`nand2tetris\projects\01`，找到里面的.hdl文件用顺手的文本编辑器打开，然后为里面的PARTS部分填空吧！

> 我开始不知道老师给了模板，就自己新建文本文档写了，所有的文件名都整成了小写字母，还需要改脚本里的名字，直接用老师的模板方便很多。下面的参考代码只用关心PARTS部分就好。

下面是我的代码链接，已经全部通过测试脚本，你可以先自己动手做完，实在搞不懂再看答案。

链接：[第一章实验结果](https://github.com/Heithon/nand2tetris-labs-and-notes/tree/main/01)

